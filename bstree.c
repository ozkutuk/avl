#include "bstree.h"

#include <stdio.h>
#include <stdlib.h>

#define MAX(a,b) (((a) > (b)) ? (a) : (b))

static int height(struct bstree_node *root)
{
    return root ? root->height : -1;
}

/* Make a node that is a valid tree consisting of one node, only the root.
 */
static struct bstree_node *mknode(void *object)
{
    struct bstree_node *root = malloc(sizeof *root);
    root->object = object;
    root->left = NULL;
    root->right = NULL;
    root->count = 1;
    root->height = 0;
    return root;
}

/* Assume the given tree is balanced or within one of being balanced.
 * We allow a maximum imbalance of 1, and we maintain it as long as the
 * tree exists. Therefore, a valid tree generated by us will eaither be balanced,
 * or a recent insertion (or deletion) created an imbalance of 2.
 * If the latter is the case, this function restores the balance.
 */
static struct bstree_node *balance(struct bstree_node *root)
{
    /* TODO
     * This is currently a no-op. This will maintain the balance and height
     * information at nodes. Now the tree works without balancing and with
     * no valid height information at nodes.
     */
    return root;
}

struct bstree_node *bstree_insert(struct bstree_node *root, const struct bstree_ops *ops, void *object)
{
    if (!root) {
        return mknode(object);
    }
    if (ops->compare_object(object, root->object) < 0) {
        root->left = bstree_insert(root->left, ops, object);
        return balance(root);
    }
    if (ops->compare_object(object, root->object) > 0) {
        root->right = bstree_insert(root->right, ops, object);
        return balance(root);
    }
    /* Inserting equal key. We are not going to hold the given pointer.
     * If it is us who manages the lifetime (the ops->free_object != NULL),
     * we should free it.
     */
    root->count++;
    if (ops->free_object) {
        ops->free_object(object);
    }
    return balance(root);
}

void bstree_destroy(struct bstree_node *root, const struct bstree_ops *ops)
{
    if (!root) {
        return;
    }
    bstree_destroy(root->left, ops);
    bstree_destroy(root->right, ops);
    if (ops->free_object) {
        ops->free_object(root->object);
    }
    free(root);
}

void bstree_traverse_inorder(const struct bstree_node *root, void (*operation)(void *object))
{
    if (!root) {
        return;
    }
    bstree_traverse_inorder(root->left, operation);
    operation(root->object);
    bstree_traverse_inorder(root->right, operation);
}

int bstree_count(const struct bstree_node *root, const struct bstree_ops *ops, const void *object)
{
    if (!root) {
        return 0;
    }
    if (ops->compare_object(object, root->object) < 0) {
        return bstree_count(root->left, ops, object);
    }
    if (ops->compare_object(object, root->object) > 0) {
        return bstree_count(root->right, ops, object);
    }
    return root->count;
}
